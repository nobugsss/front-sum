# 官网文档笔记

## 描述 UI

### 组件

- React 组件是一段可以 使用标签进行扩展 的 JavaScript 函数
- 没有括号包裹的话，任何在 return 下一行的代码都 将被忽略！
- 组件可以渲染其他组件，但是 请不要嵌套他们的定义：永远不要在组件中定义组件

### 使用 JSX 书写标签语言

JSX 是 JavaScript 语法扩展，可以让你在 JavaScript 文件中书写类似 HTML 的标签

**在 React 中，渲染逻辑和标签共同存在于同一个地方——组件**

注意: JSX and React 是相互独立的 东西。但它们经常一起使用，但你 可以 单独使用它们中的任意一个，JSX 是一种语法扩展，而 React 则是一个 JavaScript 的库

#### JSX 规则

1. 只能返回一个根元素
   - 如果想要在一个组件中包含多个元素，需要用一个父标签把它们包裹起来.如果不想在标签中增加一个额外的 <\div>，可以用 <> 和 </> 元素来代替
2. 标签必须闭合
3. 使用驼峰式命名法给 所有 大部分属性命名！

##### 为什么多个 JSX 标签需要被一个父元素包裹？

JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。

### 将 Props 传递给组件

props 是 不可变的（一个计算机科学术语，意思是“不可改变”）。当一个组件需要改变它的 props（例如，响应用户交互或新数据）时，它不得不“请求”它的父组件传递 不同的 props —— 一个新对象！它的旧 props 将被丢弃，最终 JavaScript 引擎将回收它们占用的内存

- 要传递 props，请将它们添加到 JSX，就像使用 HTML 属性一样。
- 要读取 props，请使用 function Avatar({ person, size }) 解构语法。
- 你可以指定一个默认值，如 size = 100，用于缺少值或值为 undefined 的 props 。
- 你可以使用 `<Avatar {...props} /> `JSX 展开语法转发所有 props，但不要过度使用它！
- 像 `<Card><Avatar /></Card> `这样的嵌套 JSX，将被视为 Card 组件的 children prop。
- Props 是只读的时间快照：每次渲染都会收到新版本的 props。
- 你不能改变 props。当你需要交互性时，你可以设置 state。

### 条件渲染

JSX 元素不是“实例”，因为它们没有内部状态也不是真实的 DOM 节点。它们只是一些简单的描述，就像图纸一样.

- 在 React，你可以使用 JavaScript 来控制分支逻辑。
- 你可以使用 if 语句来选择性地返回 JSX 表达式。
- 你可以选择性地将一些 JSX 赋值给变量，然后用大括号将其嵌入到其他 JSX 中。
- 在 JSX 中，{cond ? <\A /> : <\B />} 表示 “当 cond 为真值时, 渲染 <\A />，否则 <\B />”。
- 在 JSX 中，{cond && <\A />} 表示 “当 cond 为真值时, 渲染 <\A />，否则不进行渲染”。
- 快捷的表达式很常见，但如果你更倾向于使用 if，你也可以不使用它们，。

切勿将数字放在 && 左侧.

- JavaScript 会自动将左侧的值转换成布尔类型以判断条件成立与否。然而，如果左侧是 0，整个表达式将变成左侧的值（0），React 此时则会渲染 0 而不是不进行渲染。

### 渲染列表

直接放在 map() 方法里的 JSX 元素一般都需要指定 key 值！

这些 key 会告诉 React，每个组件对应着数组里的哪一项，所以 React 可以把它们匹配起来。这在数组项进行移动（例如排序）、插入或删除等操作时非常重要。一个合适的 key 可以帮助 React 推断发生了什么，从而得以正确地更新 DOM 树。

用作 key 的值应该在数据中提前就准备好，而不是在运行时才随手生成.

如果你想让每个列表项都输出多个 DOM 节点而非一个的话，Fragment 语法的简写形式 <> </> 无法接受 key 值，所以你只能要么把生成的节点用一个 <\div> 标签包裹起来，要么使用长一点但更明确的 <\Fragment> 写法, 这里的 Fragment 标签本身并不会出现在 DOM 上，这串代码最终会转换成 <\h1>、<\p>、<\h1>、<\p>…… 的列表

### 保持组件纯粹

React 提供了 “严格模式”，在严格模式下开发时，它将会调用每个组件函数两次。通过重复调用组件函数，严格模式有助于找到违反这些规则的组件。

#### React 为何侧重于纯函数?

- 你的组件可以在不同的环境下运行 — 例如，在服务器上！由于它们针对相同的输入，总是返回相同的结果，因此一个组件可以满足多个用户请求。
- 你可以为那些输入未更改的组件来 跳过渲染，以提高性能。这是安全的做法，因为纯函数总是返回相同的结果，所以可以安全地缓存它们。
- 如果在渲染深层组件树的过程中，某些数据发生了变化，React 可以重新开始渲染，而不会浪费时间完成过时的渲染。纯粹性使得它随时可以安全地停止计算。

#### 摘要

- 一个组件必须是纯粹的，就意味着：
  - 只负责自己的任务。 它不会更改在该函数调用前就已存在的对象或变量。
  - 输入相同，则输出相同。 给定相同的输入，组件应该总是返回相同的 JSX。
- 渲染随时可能发生，因此组件不应依赖于彼此的渲染顺序。
- 你不应该改变任何用于组件渲染的输入。这包括 props、state 和 context。通过 “设置” state 来更新界面，而不要改变预先存在的对象。
- 努力在你返回的 JSX 中表达你的组件逻辑。当你需要“改变事物”时，你通常希望在事件处理程序中进行。作为最后的手段，你可以使用 useEffect。

### 将 UI 视为树

#### 渲染树

react 渲染树仅由 React 组件 组成

#### 模块依赖树

在 React 应用程序中，可以使用树来建模的另一个关系是应用程序的模块依赖关系。当 拆分组件 和逻辑到不同的文件中时，就创建了 JavaScript 模块，在这些模块中可以导出组件、函数或常量。

模块依赖树中的每个节点都是一个模块，每个分支代表该模块中的 import 语句。

树的根节点是根模块，也称为入口文件。它通常包含根组件的模块。

与同一应用程序的渲染树相比，存在相似的结构，但也有一些显著的差异：

- 构成树的节点代表模块，而不是组件。
- 非组件模块，在这个树中也有所体现。渲染树仅封装组件。

依赖树对于确定运行 React 应用程序所需的模块非常有用。在为生产环境构建 React 应用程序时，通常会有一个构建步骤，该步骤将捆绑所有必要的 JavaScript 以供客户端使用。负责此操作的工具称为 bundler（捆绑器），并且 bundler 将使用依赖树来确定应包含哪些模块。

随着应用程序的增长，捆绑包大小通常也会增加。大型捆绑包大小对于客户端来说下载和运行成本高昂，并延迟 UI 绘制的时间。了解应用程序的依赖树可能有助于调试这些问题。

#### 摘要

- 树是表示实体之间关系的常见方式，它们经常用于建模 UI。
- 渲染树表示单次渲染中 React 组件之间的嵌套关系。
- 使用条件渲染，渲染树可能会在不同的渲染过程中发生变化。使用不同的属性值，组件可能会渲染不同的子组件。
- 渲染树有助于识别顶级组件和叶子组件。顶级组件会影响其下所有组件的渲染性能，而叶子组件通常会频繁重新渲染。识别它们有助于理解和调试渲染性能问题。
- 依赖树表示 React 应用程序中的模块依赖关系。
- 构建工具使用依赖树来捆绑必要的代码以部署应用程序。
- 依赖树有助于调试大型捆绑包带来的渲染速度过慢的问题，以及发现哪些捆绑代码可以被优化。

## 添加交互

### 响应事件

内置组件（<\button> 和 <\div>）仅支持 浏览器事件名称，例如 onClick。但是，当你构建自己的组件时，你可以按你个人喜好命名事件处理函数的 prop。

按照惯例，事件处理函数 props 应该以 on 开头，后跟一个大写字母。

在 React 中所有事件都会传播，除了 onScroll，它仅适用于你附加到的 JSX 标签。

与渲染函数不同，事件处理函数不需要是 纯函数，因此它是用来 更改 某些值的绝佳位置。例如，更改输入框的值以响应键入，或者更改列表以响应按钮的触发。但是，为了更改某些信息，你首先需要某种方式存储它。在 React 中，这是通过 state（组件的记忆） 来完成的

#### 摘要:

- 你可以通过将函数作为 prop 传递给元素如 <\button> 来处理事件。
- 必须传递事件处理函数，而非函数调用！ onClick={handleClick} ，不是 onClick={handleClick()}。
- 你可以单独或者内联定义事件处理函数。
- 事件处理函数在组件内部定义，所以它们可以访问 props。
- 你可以在父组件中定义一个事件处理函数，并将其作为 prop 传递给子组件。
- 你可以根据特定于应用程序的名称定义事件处理函数的 prop。
- 事件会向上传播。通过事件的第一个参数调用 e.stopPropagation() 来防止这种情况。
- 事件可能具有不需要的浏览器默认行为。调用 e.preventDefault() 来阻止这种情况。
- 从子组件显式调用事件处理函数 prop 是事件传播的另一种优秀替代方案。

### State：组件的记忆

1. **局部变量无法在多次渲染中持久保存。** 当 React 再次渲染这个组件时，它会从头开始渲染——不会考虑之前对局部变量的任何更改。
2. **更改局部变量不会触发渲染。** React 没有意识到它需要使用新数据再次渲染组件。

要使用新数据更新组件，需要做两件事：

1. **保留** 渲染之间的数据。
2. **触发** React 使用新数据渲染组件（重新渲染）。

useState Hook 提供了这两个功能：

1. **State 变量** 用于保存渲染间的数据。
2. **State setter 函数** 更新变量并触发 React 再次渲染组件。

#### Hook

Hook 是特殊的函数，只在 React **渲染**时有效。它们能让你 “hook” 到不同的 React 特性中去。

**Hooks ——以 use 开头的函数——只能在组件或自定义 Hook 的最顶层调用**。 你不能在条件语句、循环语句或其他嵌套函数内调用 Hook。

#### React 如何知道返回哪个 state

在同一组件的每次渲染中，Hooks 都依托于一个稳定的调用顺序

在 React 内部，为每个组件保存了一个数组，其中每一项都是一个 state 对。它维护当前 state 对的索引值，在渲染之前将其设置为 “0”。每次调用 useState 时，React 都会为你提供一个 state 对并增加索引值

这个例子没有使用 React，但它让你了解 useState 在内部是如何工作的：

```js
let componentHooks = [];
let currentHookIndex = 0;

// useState 在 React 中是如何工作的（简化版）
function useState(initialState) {
	let pair = componentHooks[currentHookIndex];
	if (pair) {
		// 这不是第一次渲染
		// 所以 state pair 已经存在
		// 将其返回并为下一次 hook 的调用做准备
		currentHookIndex++;
		return pair;
	}

	// 这是我们第一次进行渲染
	// 所以新建一个 state pair 然后存储它
	pair = [initialState, setState];

	function setState(nextState) {
		// 当用户发起 state 的变更，
		// 把新的值放入 pair 中
		pair[0] = nextState;
		updateDOM();
	}

	// 存储这个 pair 用于将来的渲染
	// 并且为下一次 hook 的调用做准备
	componentHooks[currentHookIndex] = pair;
	currentHookIndex++;
	return pair;
}

function updateDOM() {
	// 在渲染组件之前
	// 重置当前 Hook 的下标
	currentHookIndex = 0;

	// 更新 DOM 以匹配输出结果
	// 这部分工作由 React 为你完成

	// todolist...
}
```

#### State 是隔离且私有的

**如果你渲染同一个组件两次，每个副本都会有完全隔离的 state！**改变其中一个不会影响另一个。

**state 完全私有于声明它的组件**

#### 摘要

- 当一个组件需要在多次渲染间“记住”某些信息时使用 state 变量。
- State 变量是通过调用 useState Hook 来声明的。
- Hook 是以 use 开头的特殊函数。它们能让你 “hook” 到像 state 这样的 React 特性中。
- Hook 可能会让你想起 import：它们需要在非条件语句中调用。调用 Hook 时，包括 useState，仅在组件或另一个 Hook 的顶层被调用才有效。
- useState Hook 返回一对值：当前 state 和更新它的函数。
- 你可以拥有多个 state 变量。在内部，React 按顺序匹配它们。
- State 是组件私有的。如果你在两个地方渲染它，则每个副本都有独属于自己的 state。

### 渲染和提交

组件显示到屏幕之前，其必须被 React 渲染。

提供 UI 的过程总共包括三个步骤：

1. **触发** 一次渲染
2. **渲染** 组件
3. **提交** 到 DOM

#### 触发一次渲染

有两种原因会导致组件的渲染:

1. 组件的 初次渲染。
   - 当应用启动时，会触发初次渲染。框架和沙箱有时会隐藏这部分代码，但它是通过调用目标 DOM 节点的 createRoot，然后用你的组件调用 render 函数完成的
2. 组件（或者其祖先之一）的 状态发生了改变。
   - 一旦组件被初次渲染，你就可以通过使用 set 函数 更新其状态来触发之后的渲染。更新组件的状态会自动将一次渲染送入队列. **状态更新** --> **触发渲染** ---> **渲染**(自动将一次渲染送入队列)

#### React 渲染组件

在你触发渲染后，React 会调用你的组件来确定要在屏幕上显示的内容。**“渲染中” 即 React 在调用你的组件**。

- **在进行初次渲染时**, React 会调用根组件。
- **对于后续的渲染,** React 会调用内部状态更新触发了渲染的函数组件。
  - 这个过程是递归的：如果更新后的组件会返回某个另外的组件，那么 React 接下来就会渲染 那个 组件，而如果那个组件又返回了某个组件，那么 React 接下来就会渲染 那个 组件，以此类推。这个过程会持续下去，直到没有更多的嵌套组件并且 React 确切知道哪些东西应该显示到屏幕上为止
- **在初次渲染中**， React 将会为标签 创建 DOM 节点。
- **在一次重渲染过程中**, React 将计算它们的哪些属性（如果有的话）自上次渲染以来已更改。在下一步（提交阶段）之前，它不会对这些信息执行任何操作。

渲染必须始终是一次 **纯计算**:

- **输入相同，输出相同**。 给定相同的输入，组件应始终返回相同的 JSX。
- **只做它自己的事情。** 它不应更改任何存在于渲染之前的对象或变量。

#### React 把更改提交到 DOM 上

在渲染（调用）你的组件之后，React 将会修改 DOM。

- **对于初次渲染**， React 会使用 appendChild() DOM API 将其创建的所有 DOM 节点放在屏幕上。
- **对于重渲染**， React 将应用最少的必要操作（在渲染时计算！），以使得 DOM 与最新的渲染输出相互匹配。

**React 仅在渲染之间存在差异时才会更改 DOM 节点**。 例如，有一个组件，它每秒使用从父组件传递下来的不同属性重新渲染一次。注意，你可以添加一些文本到 <\input> 标签，更新它的 value，但是文本不会在组件重渲染时消失

#### 浏览器绘制

渲染完成并且 React 更新 DOM 之后，浏览器就会重新绘制屏幕。尽管这个过程被称为“浏览器渲染”（“browser rendering”），但我们还是将它称为“绘制”（“painting”），以避免在这些文档的其余部分中出现混淆。

#### 性能优化

如果更新的组件在树中的位置非常高，渲染更新后的组件内部所有嵌套组件的默认行为将不会获得最佳性能。如果你遇到了性能问题，[性能](https://legacy.reactjs.org/docs/optimizing-performance.html) 章节描述了几种可选的解决方案 。不要过早进行优化！

#### 摘要

- 在一个 React 应用中一次屏幕更新都会发生以下三个步骤：
  1. 触发
  2. 渲染
  3. 提交
- 你可以使用严格模式去找到组件中的错误
- 如果渲染结果与上次一样，那么 React 将不会修改 DOM

### state 如同一张快照

也许 state 变量看起来和一般的可读写的 JavaScript 变量类似。但 state 在其表现出的特性上更像是一张快照。设置它不会更改你已有的 state 变量，但会触发重新渲染。

#### 设置 state 会触发渲染

要使界面做出反应，你需要设置其 state.

#### 渲染会及时生成一张快照

“正在渲染” 就意味着 React 正在调用你的组件——一个函数。你从该函数返回的 JSX 就像是 UI 的一张及时的快照。它的 props、事件处理函数和内部变量都是 根据当前渲染时的 state 被计算出来的。

当 React 重新渲染一个组件时：

1. React 会再次调用你的函数
2. 函数会返回新的 JSX 快照
3. React 会更新界面以匹配返回的快照

作为一个组件的记忆，state 不同于在你的函数返回之后就会消失的普通变量。state 实际上“活”在 React 本身中——就像被摆在一个架子上！——位于你的函数之外。当 React 调用你的组件时，它会为特定的那一次渲染提供一张 state 快照。你的组件会在其 JSX 中返回一张包含一整套新的 props 和事件处理函数的 UI 快照 ，其中所有的值都是 **根据那一次渲染中 state 的值** 被计算出来的！

**设置 state 只会为下一次渲染变更 state 的值。**

**一个 state 变量的值永远不会在一次渲染的内部发生变化**, 即使其事件处理函数的代码是异步的。在 **那次渲染的** 内部,它的值在 React 通过调用你的组件“获取 UI 的快照”时就被“固定”了。

**React 会使 state 的值始终”固定“在一次渲染的各个事件处理函数内部。** 你无需担心代码运行时 state 是否发生了变化。

例子详解

```jsx
import { useState } from "react";

export default function Counter() {
	const [number, setNumber] = useState(0);

	return (
		<>
			<h1>{number}</h1>
			<button
				onClick={() => {
					setNumber(number + 1);
				}}>
				+1
			</button>
		</>
	);
}
```

1.  点击按钮执行 setNumber(number + 1) ----> 状态更新-- > 触发渲染
2.  触发渲染后 --> 渲染中，React 会调用组件(Counter),即内部状态更新触发了渲染的函数组件(这个过程是递归的),
    - React 将计算它们的哪些属性（如果有的话）自上次渲染以来已更改。在下一步（提交阶段）之前，它不会对这些信息执行任何操作.
3.  调用组件(一个函数)从该函数返回新的 JSX 快照.(props、事件处理函数和内部变量都是 根据**当前渲染时的 state**被计算出来的)
    - 一个 state 变量的值永远不会在一次渲染的内部发生变化
    - React 会使 state 的值始终”固定“在一次渲染的各个事件处理函数内部
4.  React 会更新界面以匹配返回的快照(React 把更改提交到 DOM 上)
5.  浏览器绘制

简洁版:

1. 触发更新：调用 setState，通知 React 状态变了；
2. 准备渲染（Render 阶段）：
   - React 重新执行组件函数；
   - 根据新的 state 和 props 返回新的 JSX；
3. 对比差异：React 比较旧的虚拟 DOM 和新的虚拟 DOM；
4. 提交更新（Commit 阶段）：
   - React 更新真实 DOM；
   - 调用必要的生命周期/副作用；
5. 浏览器绘制：页面重新渲染出新的界面。

即: **状态更新 -> 组件函数重新执行 -> 生成新 JSX -> React 比较新旧 JSX -> DOM 更新 -> 浏览器绘制**。

| 概念                                 | 说明                                                                         |
| ------------------------------------ | ---------------------------------------------------------------------------- |
| **一次渲染是完整的快照**             | 在一个渲染过程中，所有的变量都是“当前这一轮状态”的，只读，**不会中途改变**。 |
| **setState 不会立即更新**            | 状态更新是异步的，React 会批量处理它们，提高性能。                           |
| **每次 setState 会重新执行组件函数** | 每次状态变了，就会重新“调用”组件函数，生成新的 JSX，替换旧的内容。           |
| **React 只关心 JSX 返回的结果**      | React 不保存“组件函数内部的变量”，只追踪 `useState` 等 hooks 保存的状态。    |

#### 摘要

- 设置 state 请求一次新的渲染。
- React 将 state 存储在组件之外，就像在架子上一样。
- 当你调用 useState 时，React 会为你提供该次渲染 的一张 state 快照。
- 变量和事件处理函数不会在重渲染中“存活”。每个渲染都有自己的事件处理函数。
- 每个渲染（以及其中的函数）始终“看到”的是 React 提供给这个 渲染的 state 快照。
- 你可以在心中替换事件处理函数中的 state，类似于替换渲染的 JSX。
- 过去创建的事件处理函数拥有的是创建它们的那次渲染中的 state 值。

### 把一系列 state 更新加入队列

设置组件 state 会把一次重新渲染加入队列。但有时你可能会希望在下次渲染加入队列之前对 state 的值执行多次操作。

**每一次渲染的 state 值都是固定的**. 但是这里还有另外一个影响因素需要讨论。**React 会等到事件处理函数中的** 所有 **代码都运行完毕再处理你的 state 更新**。  
这让你可以更新多个 state 变量——甚至来自多个组件的 state 变量——而不会触发太多的 重新渲染。但这也意味着只有在你的事件处理函数及其中任何代码执行完成 **之后**，UI 才会更新。这种特性也就是 **批处理**，它会使你的 React 应用运行得更快。它还会帮你避免处理只 ​​ 更新了一部分 state 变量的令人困惑的“半成品”渲染。

**React 不会跨 多个 需要刻意触发的事件（如点击）进行批处理**——每次点击都是单独处理的。React 只会在一般来说安全的情况下才进行批处理。

#### 在下次渲染前多次更新同一个 state

这是一个不常见的用例，但是如果你想在下次渲染之前多次更新同一个 state，你可以像 setNumber(n => n + 1) 这样传入一个根据队列中的前一个 state 计算下一个 state 的 **函数**，而不是像 setNumber(number + 1) 这样传入 **下一个 state 值**。这是一种告诉 React “用 state 值做某事”而不是仅仅替换它的方法。在这里，n => n + 1 被称为 **更新函数**。当你将它传递给一个 state 设置函数时：

1. React 会将此函数加入队列，以便在事件处理函数中的所有其他代码运行后进行处理。
2. 在下一次渲染期间，React 会遍历队列并给你更新之后的最终 state。

#### 摘要

- 设置 state 不会更改现有渲染中的变量，但会请求一次新的渲染。
- React 会在事件处理函数执行完成之后处理 state 更新。这被称为批处理。
- 要在一个事件中多次更新某些 state，你可以使用 setNumber(n => n + 1) 更新函数。

### 更新 state 中的对象

state 中可以保存任意类型的 JavaScript 值，包括对象。但是，你不应该直接修改存放在 React state 中的对象。相反，当你想要更新一个对象时，你需要创建一个新的对象（或者将其拷贝一份），然后将 state 更新为此对象。

应该 **把所有存放在 state 中的 JavaScript 对象都视为只读的。**

#### 使用 Immer 编写简洁的更新逻辑

如果你的 state 有多层的嵌套，你或许应该考虑 将其扁平化。但是，如果你不想改变 state 的数据结构，你可能更喜欢用一种更便捷的方式来实现嵌套展开的效果。Immer 是一个非常流行的库，它可以让你使用简便但可以直接修改的语法编写代码，并会帮你处理好复制的过程。通过使用 Immer，你写出的代码看起来就像是你“打破了规则”而直接修改了对象：

```js
updatePerson((draft) => {
	draft.artwork.city = "Lagos";
});
```

#### 为什么在 React 中不推荐直接修改 state？

- **调试**：如果你使用 console.log 并且不直接修改 state，你之前日志中的 state 的值就不会被新的 state 变化所影响。这样你就可以清楚地看到两次渲染之间 state 的值发生了什么变化
- **优化**：React 常见的 优化策略 依赖于如果之前的 props 或者 state 的值和下一次相同就跳过渲染。如果你从未直接修改 state ，那么你就可以很快看到 state 是否发生了变化。如果 prevObj === obj，那么你就可以肯定这个对象内部并没有发生改变。
- **新功能**：我们正在构建的 React 的新功能依赖于 state 被 像快照一样看待 的理念。如果你直接修改 state 的历史版本，可能会影响你使用这些新功能。
- **需求变更**：有些应用功能在不出现任何修改的情况下会更容易实现，比如实现撤销/恢复、展示修改历史，或是允许用户把表单重置成某个之前的值。这是因为你可以把 state 之前的拷贝保存到内存中，并适时对其进行再次使用。如果一开始就用了直接修改 state 的方式，那么后面要实现这样的功能就会变得非常困难。
- **更简单的实现**：React 并不依赖于 mutation ，所以你不需要对对象进行任何特殊操作。它不需要像很多“响应式”的解决方案一样去劫持对象的属性、总是用代理把对象包裹起来，或者在初始化时做其他工作。这也是为什么 React 允许你把任何对象存放在 state 中——不管对象有多大——而不会造成有任何额外的性能或正确性问题的原因。

#### 摘要

- 将 React 中所有的 state 都视为不可直接修改的。
- 当你在 state 中存放对象时，直接修改对象并不会触发重渲染，并会改变前一次渲染“快照”中 state 的值。
- 不要直接修改一个对象，而要为它创建一个 新 版本，并通过把 state 设置成这个新版本来触发重新渲染。
- 你可以使用这样的 {...obj, something: 'newValue'} 对象展开语法来创建对象的拷贝。
- 对象的展开语法是浅层的：它的复制深度只有一层。
- 想要更新嵌套对象，你需要从你更新的位置开始自底向上为每一层都创建新的拷贝。
- 想要减少重复的拷贝代码，可以使用 Immer。

### 更新 state 中的数组

数组是另外一种可以存储在 state 中的 JavaScript 对象，它虽然是可变的，但是却应该被视为不可变。同对象一样，当你想要更新存储于 state 中的数组时，你需要创建一个新的数组（或者创建一份已有数组的拷贝值），并使用新数组设置 state。

#### 摘要

- 你可以把数组放入 state 中，但你不应该直接修改它。
- 不要直接修改数组，而是创建它的一份 新的 拷贝，然后使用新的数组来更新它的状态。
- 你可以使用 [...arr, newItem] 这样的数组展开语法来向数组中添加元素。
- 你可以使用 filter() 和 map() 来创建一个经过过滤或者变换的数组。
- 你可以使用 Immer 来保持代码简洁。

## 状态管理

### 用 State 响应输入

#### 声明式地考虑 UI

1. 定位你的组件中不同的视图状态
2. 确定是什么触发了这些 state 的改变
3. 表示内存中的 state（需要使用 useState）
4. 删除任何不必要的 state 变量
   - 这个 state 是否会导致矛盾
   - 相同的信息是否已经在另一个 state 变量中存在
   - 你是否可以通过另一个 state 变量的相反值得到相同的信息
5. 连接事件处理函数去设置 state

#### 摘要

- 声明式编程意味着为每个视图状态声明 UI 而非细致地控制 UI（命令式）。
- 当开发一个组件时：
  - 写出你的组件中所有的视图状态。
  - 确定是什么触发了这些 state 的改变。
  - 通过 useState 模块化内存中的 state。
  - 删除任何不必要的 state 变量。
  - 连接事件处理函数去设置 state。

### 选择 State 结构

#### 构建 state 的原则

1. **合并关联的 state**。如果你总是同时更新两个或更多的 state 变量，请考虑将它们合并为一个单独的 state 变量。
2. **避免互相矛盾的 state**。当 state 结构中存在多个相互矛盾或“不一致”的 state 时，你就可能为此会留下隐患。应尽量避免这种情况。
3. **避免冗余的 stat**e。如果你能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入该组件的 state 中。
4. **避免重复的 state**。当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少重复。
5. **避免深度嵌套的 state**。深度分层的 state 更新起来不是很方便。如果可能的话，最好以扁平化方式构建 state。

#### 不要在 state 中镜像 props

```js
function Message({ messageColor }) {
	const [color, setColor] = useState(messageColor);
}
```

这里，一个 color state 变量被初始化为 messageColor 的 prop 值。这段代码的问题在于，如果父组件稍后传递不同的 messageColor 值（例如，将其从 'blue' 更改为 'red'），则 color state 变量将不会更新！ **state 仅在第一次渲染期间初始化**。

这就是为什么在 state 变量中，“镜像”一些 prop 属性会导致混淆的原因。相反，你要在代码中直接使用 messageColor 属性。如果你想给它起一个更短的名称，请使用常量：

```js
function Message({ messageColor }) {
	const color = messageColor;
	// ------
}
// 这种写法就不会与从父组件传递的属性失去同步。
```

**如果 state 嵌套太深，难以轻松更新，可以考虑将其“扁平化”。**

#### 摘要

- 如果两个 state 变量总是一起更新，请考虑将它们合并为一个。
- 仔细选择你的 state 变量，以避免创建“极难处理”的 state。
- 用一种减少出错更新的机会的方式来构建你的 state。
- 避免冗余和重复的 state，这样您就不需要保持同步。
- 除非您特别想防止更新，否则不要将 props 放入 state 中。
- 对于选择类型的 UI 模式，请在 state 中保存 ID 或索引而不是对象本身。
- 如果深度嵌套 state 更新很复杂，请尝试将其展开扁平化。

### 在组件间共享状态

有时候，你希望两个组件的状态始终同步更改。要实现这一点，可以将相关 state 从这两个组件上移除，并把 state 放到它们的公共父级，再通过 props 将 state 传递给这两个组件。这被称为“状态提升”，这是编写 React 代码时常做的事。

**每个状态都对应唯一的数据源**

- 对于每个独特的状态，都应该存在且只存在于一个指定的组件中作为 state。

#### 摘要

- 当你想要整合两个组件时，将它们的 state 移动到共同的父组件中。
- 然后在父组件中通过 props 把信息传递下去。
- 最后，向下传递事件处理程序，以便子组件可以改变父组件的 state 。
- 考虑该将组件视为“受控”（由 prop 驱动）或是“不受控”（由 state 驱动）是十分有益的。

### 对 state 进行保留和重置

各个组件的 state 是各自独立的。根据组件在 UI 树中的位置，React 可以跟踪哪些 state 属于哪个组件。你可以控制在重新渲染过程中何时对 state 进行保留和重置。

#### 状态与渲染树中的位置相关

状态是由 React 保存的。React 通过组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来。

#### 相同位置的相同组件会使得 state 被保留下来

**对 React 来说重要的是组件在 UI 树中的位置,而不是在 JSX 中的位置！**

    - React 不知道你的函数里是如何进行条件判断的，它只会“看到”你返回的树。

#### 相同位置的不同组件会使 state 重置

当你在相同位置渲染不同的组件时，组件的整个子树都会被重置

**如果你想在重新渲染时保留 state，几次渲染中的树形结构就应该相互“匹配”**。结构不同就会导致 state 的销毁，因为 React 会在将一个组件从树中移除时销毁它的 state。

永远要将组件定义在最上层并且不要把它们的定义嵌套起来。

#### 在相同位置重置 state

1. 将组件渲染在不同的位置

   - 一般用 **&&**和组件连用, 三元运算符达不到效果(除非加上 key)

2. 使用 key 来重置 state

#### 摘要

- 只要在相同位置渲染的是相同组件， React 就会保留状态。
- state 不会被保存在 JSX 标签里。它与你在树中放置该 JSX 的位置相关联。
- 你可以通过为一个子树指定一个不同的 key 来重置它的 state。
- 不要嵌套组件的定义，否则你会意外地导致 state 被重置。

### 迁移状态逻辑至 Reducer 中

对于拥有许多状态更新逻辑的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以将组件的所有状态更新逻辑整合到一个外部函数中，这个函数叫作 reducer。

#### 使用 reducer 整合状态逻辑

reducer 函数需要：

- 声明当前状态（tasks）作为第一个参数；
- 声明 action 对象作为第二个参数；
- 从 reducer 返回 下一个 状态（React 会将旧的状态设置为这个最新的状态）。

由于 reducer 函数接受 state（tasks）作为参数，因此你可以 在组件之外声明它。这减少了代码的缩进级别，提升了代码的可读性。

#### 对比 useState 和 useReducer

- **代码体积**： 通常，在使用 useState 时，一开始只需要编写少量代码。而 useReducer 必须提前编写 reducer 函数和需要调度的 actions。但是，当多个事件处理程序以相似的方式修改 state 时，useReducer 可以减少代码量。
- **可读性**： 当状态更新逻辑足够简单时，useState 的可读性还行。但是，一旦逻辑变得复杂起来，它们会使组件变得臃肿且难以阅读。在这种情况下，useReducer 允许你将状态更新逻辑与事件处理程序分离开来。
- **可调试性**： 当使用 useState 出现问题时, 你很难发现具体原因以及为什么。 而使用 useReducer 时， 你可以在 reducer 函数中通过打印日志的方式来观察每个状态的更新，以及为什么要更新（来自哪个 action）。 如果所有 action 都没问题，你就知道问题出在了 reducer 本身的逻辑中。 然而，与使用 useState 相比，你必须单步执行更多的代码。
- **可测试性**： reducer 是一个不依赖于组件的纯函数。这就意味着你可以单独对它进行测试。一般来说，我们最好是在真实环境中测试组件，但对于复杂的状态更新逻辑，针对特定的初始状态和 action，断言 reducer 返回的特定状态会很有帮助。
- **个人偏好**： 并不是所有人都喜欢用 reducer，没关系，这是个人偏好问题。你可以随时在 useState 和 useReducer 之间切换，它们能做的事情是一样的！

#### 摘要

- 把 useState 转化为 useReducer：

  1.  通过事件处理函数 dispatch actions；
  2.  编写一个 reducer 函数，它接受传入的 state 和一个 action，并返回一个新的 state；
  3.  使用 useReducer 替换 useState；

- Reducers 可能需要你写更多的代码，但是这有利于代码的调试和测试。
- Reducers 必须是纯净的。
- 每个 action 都描述了一个单一的用户交互。
- 使用 Immer 来帮助你在 reducer 里直接修改状态。

### 使用 Context 深层传递参数

通常来说，你会通过 props 将信息从父组件传递到子组件。但是，如果你必须通过许多中间组件向下传递 props，或是在你应用中的许多组件需要相同的信息，传递 props 会变的十分冗长和不便。Context 允许父组件向其下层无论多深的任何组件提供信息，而无需通过 props 显式传递。

#### 使用 context 之前

**如果你只想把一些 props 传递到多个层级中，这并不意味着你需要把这些信息放到 context 里**

在使用 context 之前，你可以考虑以下几种替代方案：

1. **从 传递 props 开始**。 如果你的组件看起来不起眼，那么通过十几个组件向下传递一堆 props 并不罕见。
2. **抽象组件并 将 JSX 作为 children 传递 给它们**。 如果你通过很多层不使用该数据的中间组件（并且只会向下传递）来传递数据，这通常意味着你在此过程中忘记了抽象组件

#### Context 的使用场景

- **主题**： 如果你的应用允许用户更改其外观（例如暗夜模式），你可以在应用顶层放一个 context provider，并在需要调整其外观的组件中使用该 context。
- **当前账户**： 许多组件可能需要知道当前登录的用户信息。将它放到 context 中可以方便地在树中的任何位置读取它。某些应用还允许你同时操作多个账户（例如，以不同用户的身份发表评论）。在这些情况下，将 UI 的一部分包裹到具有不同账户数据的 provider 中会很方便。
- **路由**： 大多数路由解决方案在其内部使用 context 来保存当前路由。这就是每个链接“知道”它是否处于活动状态的方式。如果你创建自己的路由库，你可能也会这么做。
- **状态管理**： 随着你的应用的增长，最终在靠近应用顶部的位置可能会有很多 state。许多遥远的下层组件可能想要修改它们。通常 将 reducer 与 context 搭配使用来管理复杂的状态并将其传递给深层的组件来避免过多的麻烦。

#### 摘要

- Context 使组件向其下方的整个树提供信息。
- 传递 Context 的方法:
  1.  通过 export const MyContext = createContext(defaultValue) 创建并导出 context。
  2.  在无论层级多深的任何子组件中，把 context 传递给 useContext(MyContext) Hook 来读取它。
  3.  在父组件中把 children 包在 `<MyContext.Provider value={...}>` 中来提供 context。
- Context 会穿过中间的任何组件。
- Context 可以让你写出 “较为通用” 的组件。
- 在使用 context 之前，先试试传递 props 或者将 JSX 作为 children 传递。

### 使用 Reducer 和 Context 拓展你的应用

Reducer 可以整合组件的状态更新逻辑。Context 可以将信息深入传递给其他组件。你可以组合使用它们来共同管理一个复杂页面的状态。

#### 摘要

- 你可以将 reducer 与 context 相结合，让任何组件读取和更新它的状态。
- 为子组件提供 state 和 dispatch 函数：
  1.  创建两个 context (一个用于 state,一个用于 dispatch 函数)。
  2.  让组件的 context 使用 reducer。
  3.  使用组件中需要读取的 context。
- 你可以通过将所有传递信息的代码移动到单个文件中来进一步整理组件。
  1.  你可以导出一个像 TasksProvider 可以提供 context 的组件。
  2.  你也可以导出像 useTasks 和 useTasksDispatch 这样的自定义 Hook。
- 你可以在你的应用程序中大量使用 context 和 reducer 的组合。

## 脱围机制

有些组件可能需要控制和同步 React 之外的系统。例如，你可能需要使用浏览器 API 聚焦输入框，或者在没有 React 的情况下实现视频播放器，或者连接并监听远程服务器的消息。在本章中，你将学习到一些脱围机制，让你可以“走出” React 并连接到外部系统。大多数应用逻辑和数据流不应该依赖这些功能。

### 使用 ref 引用值

当你希望组件“记住”某些信息，但又不想让这些信息 触发新的渲染 时，你可以使用 ref 。

#### 何时使用 ref

通常，当你的组件需要“跳出” React 并与外部 API 通信时，你会用到 ref —— 通常是不会影响组件外观的浏览器 API。以下是这些罕见情况中的几个：

- 存储 timeout ID
- 存储和操作 DOM 元素
- 存储不需要被用来计算 JSX 的其他对象。

如果你的组件需要存储一些值，但不影响渲染逻辑，请选择 ref。

#### ref 的最佳实践

遵循这些原则将使你的组件更具可预测性：

**将 ref 视为脱围机制**。当你使用外部系统或浏览器 API 时，ref 很有用。如果你很大一部分应用程序逻辑和数据流都依赖于 ref，你可能需要重新考虑你的方法。
**不要在渲染过程中读取或写入 ref.current**。 如果渲染过程中需要某些信息，请使用 state 代替。由于 React 不知道 ref.current 何时发生变化，即使在渲染时读取它也会使组件的行为难以预测。（唯一的例外是像 if (!ref.current) ref.current = new Thing() 这样的代码，它只在第一次渲染期间设置一次 ref。）

#### 摘要

- ref 是一种脱围机制，用于保留不用于渲染的值。 你不会经常需要它们。
- ref 是一个普通的 JavaScript 对象，具有一个名为 current 的属性，你可以对其进行读取或设置。
- 你可以通过调用 useRef Hook 来让 React 给你一个 ref。
- 与 state 一样，ref 允许你在组件的重新渲染之间保留信息。
- 与 state 不同，设置 ref 的 current 值不会触发重新渲染。
- 不要在渲染过程中读取或写入 ref.current。这使你的组件难以预测。

### 使用 ref 操作 DOM

#### 摘要

- Refs 是一个通用概念，但大多数情况下你会使用它们来保存 DOM 元素。
- 你通过传递 `<div ref={myRef}> `指示 React 将 DOM 节点放入 myRef.current。
- 通常，你会将 refs 用于非破坏性操作，例如聚焦、滚动或测量 DOM 元素。
- 默认情况下，组件不暴露其 DOM 节点。 您可以通过使用 forwardRef 并将第二个 ref 参数传递给特定节点来暴露 DOM 节点。
- 避免更改由 React 管理的 DOM 节点。
- 如果你确实修改了 React 管理的 DOM 节点，请修改 React 没有理由更新的部分。

### 使用 Effect 同步

有些组件需要与外部系统同步。例如，你可能希望根据 React state 控制非 React 组件、设置服务器连接或在组件出现在屏幕上时发送分析日志。Effects 会在渲染后运行一些代码，以便可以将组件与 React 之外的某些系统同步。

React 组件中的两种逻辑类型：

**渲染逻辑代码**（在 描述 UI 中有介绍）位于组件的顶层。
**事件处理程序**（在 添加交互性 中介绍）是嵌套在组件内部的函数，而不仅仅是计算函数。

Effect 允许你指定由渲染本身，而不是特定事件引起的副作用。Effect 在屏幕更新后的 **提交阶段** 运行。这是一个很好的时机，可以将 React 组件与某个外部系统（如网络或第三方库）同步。

不要随意在你的组件中使用 Effect。记住，Effect 通常用于暂时“跳出” React 代码并与一些 外部 系统进行同步。这包括浏览器 API、第三方小部件，以及网络等等。如果你想用 Effect 仅根据其他状态调整某些状态，那么 你可能不需要 Effect。

#### 如何编写 Effect

编写 Effect 需要遵循以下三个规则：

1. **声明 Effect**。默认情况下，Effect 会在每次渲染后都会执行。
   - 每当组件渲染时，React 将更新屏幕，然后运行 useEffect 中的代码。换句话说，useEffect 会把这段代码放到屏幕更新渲染之后(提交阶段)执行。
2. **指定 Effect 依赖**。大多数 Effect 应该按需执行，而不是在每次渲染后都执行。例如，淡入动画应该只在组件出现时触发。连接和断开服务器的操作只应在组件出现和消失时，或者切换聊天室时执行。文章将介绍如何通过指定依赖来控制如何按需执行。
   - 一般来说，Effect 会在 每次 渲染时执行。但更多时候，并不需要每次渲染的时候都执行 Effect。
     - 有时这会拖慢运行速度。因为与外部系统的同步操作总是有一定时耗，在非必要时可能希望跳过它。例如，没有人会希望每次用键盘打字时都重新连接聊天服务器。
     - 有时这会导致程序逻辑错误。例如，组件的淡入动画只需要在第一轮渲染出现时播放一次，而不是每次触发新一轮渲染后都播放。
3. **必要时添加清理（cleanup）函数**。有时 Effect 需要指定如何停止、撤销，或者清除它的效果。例如，“连接”操作需要“断连”，“订阅”需要“退订”，“获取”既需要“取消”也需要“忽略”。你将学习如何使用 清理函数 来做到这一切。
   - 每次重新执行 Effect 之前，React 都会调用清理函数；组件被卸载时，也会调用清理函数.

一般来说，Effect 会在 每次 渲染后执行，而以下代码会陷入死循环中：

```jsx
const [count, setCount] = useState(0);
useEffect(() => {
	setCount(count + 1);
});
```

没有依赖数组作为第二个参数，与依赖数组位空数组 [] 的行为是不一致的：

```jsx
useEffect(() => {
	// 这里的代码会在每次渲染后执行
});

useEffect(() => {
	// 这里的代码只会在组件挂载后执行
}, []);

useEffect(() => {
	//这里的代码只会在每次渲染后，并且 a 或 b 的值与上次渲染不一致时执行
}, [a, b]);
```

#### 初始化应用时不需要使用 Effect 的情形

某些逻辑应该只在应用程序启动时运行一次。比如，验证登陆状态和加载本地程序数据。你可以将其放在组件之外, 这保证了这种逻辑在浏览器加载页面后只运行一次。

#### 不要在 Effect 中执行购买商品一类的操作

#### 摘要

- 与事件不同，Effect 是由渲染本身，而非特定交互引起的。
- Effect 允许你将组件与某些外部系统（第三方 API、网络等）同步。
- 默认情况下，Effect 在每次渲染（包括初始渲染）后运行。
- 如果 React 的所有依赖项都与上次渲染时的值相同，则将跳过本次 Effect。
- 不能随意选择依赖项，它们是由 Effect 内部的代码决定的。
- 空的依赖数组（[]）对应于组件“挂载”，即添加到屏幕上。
- 仅在严格模式下的开发环境中，React 会挂载两次组件，以对 Effect 进行压力测试。
- 如果 Effect 因为重新挂载而中断，那么需要实现一个清理函数。
- React 将在下次 Effect 运行之前以及卸载期间这两个时候调用清理函数。

### 你可能不需要 Effect (官网文档有些内容理解的比较模糊)

Effect 是 React 范式中的一种脱围机制。它们让你可以 “逃出” React 并使组件和一些外部系统同步，比如非 React 组件、网络和浏览器 DOM。如果没有涉及到外部系统（例如，你想根据 props 或 state 的变化来更新一个组件的 state），你就不应该使用 Effect。移除不必要的 Effect 可以让你的代码更容易理解，运行得更快，并且更少出错。

有两种不必使用 Effect 的常见情况：

- 你不必使用 Effect 来转换渲染所需的数据.
- 你不必使用 Effect 来处理用户事件。

#### 缓存昂贵的计算

你可以使用 useMemo Hook 缓存（或者说 记忆（memoize））一个昂贵的计算。

```jsx
import { useMemo, useState } from "react";

function TodoList({ todos, filter }) {
	const [newTodo, setNewTodo] = useState("");

	// 🔴 避免：多余的 state 和不必要的 Effect
	const [visibleTodos, setVisibleTodos] = useState([]);
	useEffect(() => {
		setVisibleTodos(getFilteredTodos(todos, filter));
	}, [todos, filter]);

	// ...
}

// 这会告诉 React，除非 todos 或 filter 发生变化，否则不要重新执行传入的函数。React 会在初次渲染的时候记住 getFilteredTodos() 的返回值。在下一次渲染中，它会检查 todos 或 filter 是否发生了变化。如果它们跟上次渲染时一样，useMemo 会直接返回它最后保存的结果。如果不一样，React 将再次调用传入的函数（并保存它的结果）。
// 你传入 useMemo 的函数会在渲染期间执行，所以它仅适用于 纯函数 场景。
function TodoList({ todos, filter }) {
	const [newTodo, setNewTodo] = useState("");
	const visibleTodos = useMemo(() => {
		// ✅ 除非 todos 或 filter 发生变化，否则不会重新执行
		return getFilteredTodos(todos, filter);
	}, [todos, filter]);
	// ...
}
```

#### 订阅外部 store

有时候，你的组件可能需要订阅 React state 之外的一些数据。这些数据可能来自第三方库或内置浏览器 API。由于这些数据可能在 React 无法感知的情况下发变化，你需要在你的组件中手动订阅它们。这经常使用 Effect 来实现，例如：

```jsx
function useOnlineStatus() {
	// 不理想：在 Effect 中手动订阅 store
	const [isOnline, setIsOnline] = useState(true);
	useEffect(() => {
		function updateState() {
			setIsOnline(navigator.onLine);
		}

		updateState();

		window.addEventListener("online", updateState);
		window.addEventListener("offline", updateState);
		return () => {
			window.removeEventListener("online", updateState);
			window.removeEventListener("offline", updateState);
		};
	}, []);
	return isOnline;
}

function ChatIndicator() {
	const isOnline = useOnlineStatus();
	// ...
}
```

这个组件订阅了一个外部的 store 数据（在这里，是浏览器的 navigator.onLine API）。由于这个 API 在服务端不存在（因此不能用于初始的 HTML），因此 state 最初被设置为 true。每当浏览器 store 中的值发生变化时，组件都会更新它的 state。

尽管通常可以使用 Effect 来实现此功能，但 React 为此针对性地提供了一个 Hook 用于订阅外部 store。删除 Effect 并将其替换为调用 useSyncExternalStore：

```jsx
function subscribe(callback) {
	window.addEventListener("online", callback);
	window.addEventListener("offline", callback);
	return () => {
		window.removeEventListener("online", callback);
		window.removeEventListener("offline", callback);
	};
}

function useOnlineStatus() {
	// ✅ 非常好：用内置的 Hook 订阅外部 store
	return useSyncExternalStore(
		subscribe, // 只要传递的是同一个函数，React 不会重新订阅
		() => navigator.onLine, // 如何在客户端获取值
		() => true // 如何在服务端获取值
	);
}

function ChatIndicator() {
	const isOnline = useOnlineStatus();
	// ...
}
```

与手动使用 Effect 将可变数据同步到 React state 相比，这种方法能减少错误。通常，你可以写一个像上面的 useOnlineStatus() 这样的自定义 Hook，这样你就不需要在各个组件中重复写这些代码。[阅读更多关于在 React 组件中订阅外部数据 store 的信息](https://react.docschina.org/reference/react/useSyncExternalStore)。

#### 摘要

- 如果你可以在渲染期间计算某些内容，则不需要使用 Effect。
- 想要缓存昂贵的计算，请使用 useMemo 而不是 useEffect。
- 想要重置整个组件树的 state，请传入不同的 key。
- 想要在 prop 变化时重置某些特定的 state，请在渲染期间处理。
- 组件 显示 时就需要执行的代码应该放在 Effect 中，否则应该放在事件处理函数中。
- 如果你需要更新多个组件的 state，最好在单个事件处理函数中处理。
- 当你尝试在不同组件中同步 state 变量时，请考虑状态提升。
- 你可以使用 Effect 获取数据，但你需要实现清除逻辑以避免竞态条件。

### 响应式 Effect 的生命周期

Effect 与组件有不同的生命周期。组件可以挂载、更新或卸载。Effect 只能做两件事：开始同步某些东西，然后停止同步它。如果 Effect 依赖于随时间变化的 props 和 state，这个循环可能会发生多次。React 提供了代码检查规则来检查是否正确地指定了 Effect 的依赖项，这能够使 Effect 与最新的 props 和 state 保持同步。

Effect 描述了如何将外部系统与当前的 props 和 state 同步。

Props 和 state 并不是唯一的响应式值。从它们计算出的值也是响应式的。如果 props 或 state 发生变化，组件将重新渲染，从中计算出的值也会随之改变。这就是为什么 Effect 使用的组件主体中的所有变量都应该在依赖列表中。

组件内部的所有值（包括 props、state 和组件体内的变量）都是响应式的。任何响应式值都可以在重新渲染时发生变化，所以需要将响应式值包括在 Effect 的依赖项中。

#### 摘要

- 组件可以挂载、更新和卸载。
- 每个 Effect 与周围组件有着独立的生命周期。
- 每个 Effect 描述了一个独立的同步过程，可以 开始 和 停止。
- 在编写和读取 Effect 时，要独立地考虑每个 Effect（如何开始和停止同步），而不是从组件的角度思考（如何挂载、更新或卸载）。
- 在组件主体内声明的值是“响应式”的。
- 响应式值应该重新进行同步 Effect，因为它们可以随着时间的推移而发生变化。
- 检查工具验证在 Effect 内部使用的所有响应式值都被指定为依赖项。
- 检查工具标记的所有错误都是合理的。总是有一种方法可以修复代码，同时不违反规则。

### 将事件从 Effect 中分开

事件处理函数只有在你再次执行同样的交互时才会重新运行。Effect 和事件处理函数不一样，它只有在读取的 props 或 state 值和上一次渲染不一样时才会重新同步。有时你需要这两种行为的混合体：即一个 Effect 只在响应某些值时重新运行，但是在其他值变化时不重新运行。

#### Effect Event 的局限性

- 只在 Effect 内部调用他们。
- 永远不要把他们传给其他的组件或者 Hook。

使用 useEffectEvent 这个特殊的 Hook 从 Effect 中提取非响应式逻辑：

永远直接在使用他们的 Effect 旁边声明 Effect Event：

```jsx
function Timer() {
	const [count, setCount] = useState(0);
	useTimer(() => {
		setCount(count + 1);
	}, 1000);
	return <h1>{count}</h1>;
}

function useTimer(callback, delay) {
	const onTick = useEffectEvent(() => {
		callback();
	});

	useEffect(() => {
		const id = setInterval(() => {
			onTick(); // ✅ Good: 只在 Effect 内部局部调用
		}, delay);
		return () => {
			clearInterval(id);
		};
	}, [delay]); // 不需要指定 “onTick” (Effect Event) 作为依赖项
}
```

#### 摘要

- 事件处理函数在响应特定交互时运行。
- Effect 在需要同步的时候运行。
- 事件处理函数内部的逻辑是非响应式的。
- Effect 内部的逻辑是响应式的。
- 你可以将非响应式逻辑从 Effect 移到 Effect Event 中。
- 只在 Effect 内部调用 Effect Event。
- 不要将 Effect Event 传给其他组件或者 Hook。

### 移除 Effect 依赖

#### 摘要

- 依赖应始终与代码匹配。
- 当你对依赖不满意时，你需要编辑的是代码。
- 抑制 linter 会导致非常混乱的错误，你应该始终避免它。
- 要移除依赖，你需要向 linter “证明”它不是必需的。
- 如果某些代码是为了响应特定交互，请将该代码移至事件处理的地方。
- 如果 Effect 的不同部分因不同原因需要重新运行，请将其拆分为多个 Effect。
- 如果你想根据以前的状态更新一些状态，传递一个更新函数。
- 如果你想读取最新值而不“反应”它，请从 Effect 中提取出一个 Effect Event。
- 在 JavaScript 中，如果对象和函数是在不同时间创建的，则它们被认为是不同的。
- 尽量避免对象和函数依赖。将它们移到组件外或 Effect 内。

### 使用自定义 Hook 复用逻辑

#### 摘要

- 自定义 Hook 让你可以在组件间共享逻辑。
- 自定义 Hook 命名必须以后跟一个大写字母的 use 开头。
- 自定义 Hook 共享的只是状态逻辑，不是状态本身。
- 你可以将响应值从一个 Hook 传到另一个，并且他们会保持最新。
- 每次组件重新渲染时，所有的 Hook 会重新运行。
- 自定义 Hook 的代码应该和组件代码一样保持纯粹。
- 把自定义 Hook 收到的事件处理函数包裹到 Effect Event。
- 不要创建像 useMount 这样的自定义 Hook。保持目标具体化。
- 如何以及在哪里选择代码边界取决于你。
