### 所有改原数组的方法包括 es6

- 增：push / unshift
- 删：pop / shift
- 改：splice / fill
- 位置操作：reverse / copyWithin
- 排序：sort

### ES5/ES6 的继承除了写法以外还有什么区别？

- class 声明不会提升。（类似于 let、const 声明变量；
- class 声明内部会启用严格模式；
- class 的所有方法（包括静态方法和实例方法）都是不可枚举的；
- class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有 [[constructor]]，不能使用 new 来调用；
- 必须使用 new 来调用 class；
- class 内部无法重写类名；

### Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？

- Object.defineProperty 无法低耗费的监听到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
- Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历。如果属性值是对象，还需要深度遍历。 Proxy 可以劫持整个对象， 并返回一个新的对象。
- Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。

### 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没有找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言，map 映射的速度更快。

### ['1', '2', '3'].map(parseInt) what & why ?

- 输出结果为 [1, NaN, NaN]
- parseInt(1, 0) --> 0
- parseInt(2, 1) --> NaN
- parseInt(3, 2) --> NaN

### 什么是防抖和节流？有什么区别？如何实现？

**防抖**
触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。

```javascript
function debounce(fn, timing) {
	let timer;
	return function () {
		clearTimeout(timer);
		timer = setTimeout(() => {
			fn();
		}, timing);
	};
}
```

**节流**
高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行效率。

```javascript
function throttle(fn, timing) {
	let trigger;
	return function () {
		if (trigger) return;
		trigger = true;
		fn();
		setTimeout(() => {
			trigger = false;
		}, timing);
	};
}
```

_tips: DTTV（Debounce Timer Throttle Variable - 防抖靠定时器控制，节流靠变量控制）。_

### 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

**Set**

- 成员不能重复；
- 只有键值，没有键名，有点类似数组；
- 可以遍历，方法有 add、delete、has
  **WeakSet**
- 成员都是对象（引用）；
- 成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露；
- 不能遍历，方法有 add、delete、has；
  **Map**
- 本质上是键值对的集合，类似集合，“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键;
- 可以遍历，方法很多，可以跟各种数据格式转换；
- 实例方法有 set,get,has,delete,clear, keys, values,entries,forEach
  **WeakMap**
- 只接收对象为键名（null 除外），不接受其他类型的值作为键名；
- 键名指向的对象，不计入垃圾回收机制；
- 不能遍历，方法同 get、set、has、delete；
- 它的键名所引用的对象都是弱引用  
  [详情](https://es6.ruanyifeng.com/#docs/set-map#Map)

### setTimeout、Promise、Async/Await 的区别

- setTimeout: setTimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行；

- Promise: Promise 本身是同步的立即执行函数，当在 executor 中执行 resolve 或者 reject 的时候，此时是异步操作，会先执行 then/catch 等，当主栈完成时，才会去调用 resolve/reject 方法中存放的方法。  
  有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）  
  只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）  
  [详情](https://es6.ruanyifeng.com/#docs/promise)

- async: async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。  
  是 Generator 函数的语法糖,内置执行器.
  [详情](https://es6.ruanyifeng.com/#docs/async)

### 简述一下 Generator 函数

- Generator 函数是 ES6 对协程的实现，Generator 函数被称为“半协程”，意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。
- Generator 函数是一个状态机，封装了多个内部状态。
- 返回的也不是函数运行结果，而是一个指向内部状态的指针对象。
- 它执行产生的上下文环境，一旦遇到 yield 命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行 next 命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。

[详情](https://es6.ruanyifeng.com/#docs/generator)

### JS 异步解决方案的发展历程以及优缺点

**回调函数**

- 优点：解决了同步的问题（整体任务执行时长）；
- 缺点：回调地狱，不能用 try catch 捕获错误，不能 return;

**Promise**

- 优点：解决了回调地狱的问题；
- 缺点：无法取消 Promise，错误需要通过回调函数来捕获；

  **Generator**

- 特点：可以控制函数的执行。

**Async/Await**

- 优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题；使代码看起来更像同步代码，逻辑更加线性，减少了嵌套层级，使得代码更容易理解和维护 ‌
- 缺点：如果多个异步操作没有依赖性而使用 await 会导致性能上的降低；

### 下面代码中 a 在什么情况下会打印 1？

```JavaScript
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
```

```JavaScript
var a = {
  value: 0,
  // toString也行
  valueOf() {
    return ++this.value;
  }
  // 在 == 比较或算术运算中，JavaScript 会尝试将对象转成原始值， 先调用 valueOf()，如果返回的是原始值（number、string、boolean等）就用它
  // 否则，继续调用 toString()，如果还不是原始值 → 抛错（TypeError）

};
// 其他方式（利用 getter）
var i = 1;
Object.defineProperty(globalThis, "a", {
  get() {
    return i++;
  }
});
```

**原理解释：**

- 当 == 比较时，JavaScript 会尝试把对象转换为原始类型；
- 默认会调用 valueOf() 或 toString()
  - 过程：先尝试 valueOf()如果返回原始类型（如 string、number、boolean），就使用这个值；否则尝试 toString()如果返回原始类型，就使用这个值；如果都失败（返回的还是对象），抛出 TypeError

### call 和 apply 的区别是什么，哪个性能更好一些

- Function.prototype.apply 和 Function.prototype.call 的作用是一样的，区别在于传入参数的不同；
- 第一个参数都是指定函数体内 this 的指向；
- 第二个参数开始不同，apply 是传入带下标的集合，数组或者类数组，apply 把它传给函数作为参数，call 从第二个开始传入的参数是不固定的，都会传给函数作为参数；
- call 比 apply 的性能要好，call 传入参数的格式正式内部所需要的格式；

### 箭头函数与普通函数（function）的区别是什么？

- 箭头函数没有自己的 this 对象，函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象；
- 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替；
- 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数；
- 不可以当作构造函数，也就是说不可以使用 new 命令，因为：
  - 没有自己的 this，无法调用 call、apply；
  - 没有 prototype 属性，而 new 命令在执行时需要将钩子函数的 prototype 赋值给新的对象的 **proto**

### ES6 代码转成 ES5 代码的实现思路是什么？

Babel 的实现方式：

- 将代码字符串解析成抽象语法树，即所谓的 AST；
- 对 AST 进行处理，在这个阶段可以对 ES6 AST 进行相应转换，即转换成 ES5 AST；
- 根据处理后的 AST 再生成代码字符串；

### 什么是 js 事件委托/代理

- 将事件监听器添加到一个父元素上，而不是直接添加到每一个子元素上，基于浏览器的“事件冒泡”（Event Bubbling）机制。当事件（如点击、鼠标移动等）发生在一个元素上时，这个事件不仅会在最初被触发的元素上触发，还会继续向上“冒泡”到其父元素，直至 document 对象。通过在父元素上设置一个事件监听器，我们可以捕获到所有子元素的事件，然后根据事件的 target 属性来判断具体是哪个子元素触发了事件。(‌ 无论事件绑定在哪个元素上，捕获阶段的事件总是先于冒泡阶段执行 ‌。)

### 事件冒泡与事件捕获的区别

传播方向

- ‌ 事件冒泡 ‌：事件从触发的最内层元素（目标元素）开始，逐级向上传播到 DOM 树的根节点。例如点击按钮时，事件先由按钮触发，再依次触发父元素直至文档根节点。
- ‌ 事件捕获 ‌：与冒泡相反，事件从 DOM 根节点开始，逐级向下传播到目标元素。例如点击按钮时，事件先由文档根节点捕获，再依次向下传递到按钮。

触发顺序

- ‌ 事件冒泡 ‌：子元素的事件处理程序先于父元素执行（由内到外）。
- ‌ 事件捕获 ‌：父元素的事件处理程序先于子元素执行（由外到内）。

默认行为与设置

- 大多数浏览器默认在 ‌ 冒泡阶段 ‌ 处理事件（如 onclick）。
- 可通过 addEventListener 的第三个参数（useCapture）切换阶段：
  - true：捕获阶段处理。
  - false 或省略：冒泡阶段处理。

应用场景

- ‌ 事件冒泡 ‌：
  - ‌ 事件委托 ‌：将事件绑定到父元素，利用冒泡机制统一处理子元素事件（如动态列表项点击）。
  - 减少内存消耗和 DOM 操作，提升性能。
- ‌ 事件捕获 ‌：
  - ‌ 前置拦截 ‌：在事件到达目标前进行验证或修改（如表单输入预处理）。
  - ‌ 细粒度控制 ‌：需优先处理父级逻辑的场景。

### MVC、MVP、MVVM 模式的理解

**区别：**

| 模式     | 谁操作 DOM（View）？ | 数据和视图如何同步？            | 控制器/中介者角色             |
| -------- | -------------------- | ------------------------------- | ----------------------------- |
| **MVC**  | 开发者手动操作 DOM   | 手动绑定/刷新 DOM               | Controller 主动协调           |
| **MVP**  | Presenter 更新视图   | 由 Presenter 控制 View 和 Model | Presenter（主持人/协调者）    |
| **MVVM** | Vue 自动绑定 DOM     | 自动双向绑定，响应式系统        | Vue 实例（ViewModel）自动管理 |

**控制器角色的职责是：**

- MVC → Controller：接收用户输入，更新 Model，有时也操作 View。
- MVP → Presenter：完全控制 View 和 Model，View 是被动展示的,DOM 的操作一般集中在 View 层（UI 组件）中完成，由 Presenter 来驱动的。
- MVVM → ViewModel：既 vue 实例通过数据绑定和监听机制，让 View 和 Model 自动同步。

### js 中有哪几种内存泄露的情况

- 意外的全局变量；
- 闭包；
- 未被清空的定时器；
- 未被销毁的事件监听；
- DOM 引用；

### 跨域问题如何解决

- JSONP
- CORS（Cross-Origin-Resource-Share，跨域资源共享），由服务端设置响应头通过浏览器的同源策略限制

### 简述执行上下文/执行环境（不推荐的叫法）和执行栈

**执行上下文是 JavaScript 代码运行时的环境，它定义了变量和函数的作用域、this 的绑定方式，以及它们可以访问的数据。**

**一个执行上下文包含三个主要部分：**

- 变量环境（Variable Environment）：变量、函数声明等；**变量环境是对早期（es5） 变量对象（Variable Object, VO） 的一个“语义升级”或“抽象提升”，本质是同一个东西，但 ES6 起有所扩展和区分。**
- 词法环境（Lexical Environment）：作用域链；（用于处理 let、const、块级作用域；也用于创建作用域链。）
- this 绑定：当前 this 的值；

注意：变量对象（VO）,活动对象（AO）是早期规范的说法， es6 后 VO -> 变量环境（Variable Environment）; AO -> 函数执行上下文中的环境记录（environment record）

**常见执行上下文类型：**

- 全局执行上下文：代码一开始创建，全局变量/函数等都存在这里；
- 函数执行上下文：每次调用函数都会创建一个新的执行上下文；
- eval 执行上下文：一般不用；

**执行栈**

- 执行栈就是一个栈结构（后进先出 LIFO），记录当前正在执行哪些上下文。
  - 浏览器首次载入脚本，它将创建全局执行上下文，并压入执行栈栈顶（不可被弹出）
  - 每执行一个函数，就会把这个函数的执行上下文压入栈中；
  - 函数执行完，就把上下文从栈顶弹出。

### 简述作用域和作用域链

**作用域**

- 作用域是代码中定义变量的区域，决定了变量的可访问性和生命周期。
  - 通俗点说：作用域就是你能在哪些地方访问到某个变量。

**作用域链**

当函数被定义时，它会记录创建它时的词法环境（即作用域链）。这个信息保存在函数的内部属性中。当函数被调用时，JavaScript 引擎会创建一个新的执行上下文，它的作用域链是以定义时的作用域为基础，在其前端添加一个新的活动对象（用于存储函数的局部变量和参数），从而形成完整的变量查找链。

<!-- * 当代码在一个环境中执行时，会创建变量对象的作用域链。 -->

- 作用域链用于确保 JavaScript 在执行过程中，能够按照词法作用域的嵌套关系，有序地查找并访问当前执行上下文及其外层上下文中的变量和函数。
  - 简洁版：作用域链用于根据作用域的嵌套结构，依次查找变量和函数的定义，确保在当前上下文中正确访问所需标识符。
- 作用域链的本质:
  - es5: 是一个指向变量对象的指针列表。
  - es6: 作用域链的本质是一个由多个词法环境（Lexical Environment）组成的链表结构，每个环境记录都有指向其外层环境的引用。
- **作用域链定义：由多个词法环境（Lexical Environment）通过指向其外部词法环境的引用（[[OuterEnv]]）串联而成的链式结构。它用于查找变量和函数的声明，确保在执行代码时，能正确访问当前上下文中的变量以及外层作用域的变量。**

**区别：**
| 项目 | 作用域 | 作用域链 |
| ------ | --------------- | ---------------------- |
| 是什么 | **变量在哪能访问到** | **引擎怎么按链查找变量** |
| 静态还是动态 | ✅ 静态结构，写代码时就能确定 | ✅ 动态结构，运行时创建 |
| 查找方式 | 指定范围是否可以使用某个变量 | 遇到变量名时，引擎会按链从当前到全局查找变量 |

### 什么是 CSP？

- CSP（Content-Security-Policy）指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
- 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 <\meta http-equiv="Content-Security-Policy">
- CSP 也是解决 XSS 攻击的一个强力手段。

### 什么是 CSRF 攻击？如何防范 CSRF 攻击？

CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态（cookie），绕过后台的用户验证，冒充用户向服务器执行一些操作。  
CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。
**防护方法：**

- 同源检测，服务器检测请求来源；
- 使用 token 来进行验证；
- 设置 cookie 时设置 Samesite，限制 cookie 不能作为被第三方使用；

### 谈一谈你理解的函数式编程？

“函数式变成”是一种“编程范式”，也就是如何编写程序的方法论。
**核心概念**

- 纯函数
- 高阶函数
- 函数组合
- 不可变性
- 惰性求值
- 递归
- 柯里化

### 什么是尾调用，使用尾调用有什么好处？

- 尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。
- ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。

### 简述一下 PWA

PWA（Progressive Web App）渐进式网页应用，目的是提升 Web App 的性能，改善 Web App 的用户体验。
**特点**

- 可安装：可以像原生 APP 在主屏幕上留有图标。
- 离线应用：可以离线使用，背后用的是技术是 Service Worker
- Service Worker 实际上是一段脚本，在后台运行。作为一个独立的线程，运行环境和普通脚本不同，所以不能直接参与 Web 交互行为，属于一种客户端代理。
- Service Worker 可以创建有效的离线体验，拦截网络请求，并根据网络是否可用判断是否使用缓存数据或者更新缓存数据。
- 消息推送

### 介绍下 CacheStorage

CacheStorage 接口表示 Cache 对象的存储。它提供了一个 ServiceWorker、其他类型 woker 或者 window 范围内可以访问到的所有命名 cache 的主目录（它并不是一定要和 service workers 一起使用，即使它是在 service workers 规范中定义的），并维护一份字符串名称到相应 Cache 对象的映射。

CacheStorage 和 Cache，是两个与缓存相关的接口，用于管理当前网页/Web App 的缓存；在使用 Service Worker 时基本都会用到。它们与数据库有点类似，我们可以用 mongodb 来打个比喻：

- CacheStorage 管理者所有的 Cache，是整个缓存 api 的入口，类似于 mongo；
- Cache 是单个缓存库，通常一个 app 会有一个，类似 mongo 里的每个 db；  
  无论在 ServiceWorker 域或 window 域下，你都可以用 caches 来访问全局的 CacheStorage。

### 简述一下 WebAssembly

- WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 - 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C/C++ 等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 Javascript 共存，允许两者一起工作。
- WebAssembly 提供了一条途径，以使得以各种语言编写的代码都可以以接近原生的速度在 Web 中运行。

### 谈谈移动端点击

**移动端 300 ms 点击（click 事件）延迟**
由于移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，判断这次操作是不是双击。
解决方案：

- 禁用缩放：user-scalable=no
- 更改默认的视口宽度
- CSS touch-action

**点击穿透问题**
因为 click 事件的 300ms 延迟问题，所以有可能会在某些情况触发多次事件
解决方案：

- 只用 touch
- 只用 click

### 谈谈 Git-Rebase

- 可以合并多次提交记录，减少无用的提交信息；
- 合并分支并且减少 commit 记录；

### 简述懒加载

懒加载是一种延迟加载技术，仅在资源需要时才加载，以减少初始加载时间并优化性能。

懒加载的优点：

- 提升用户体验，加快首屏渲染速度；
- 减少无效资源的加载；
- 防止并发加载的资源过多会阻塞 js 的加载；  
  懒加载的原理：  
  首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在 data-original 属性中，当页面滚动的时候需要去监听 scroll 事件，在 scroll 事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区内则将图片的 src 属性设置为 data-original 的值，这样就可以实现延迟加载。

### webpack 中 loader 和 plugin 的区别是什么？

- loader：loader 是一个转换器，将 A 文件进行编译成 B 文件，属于单纯的文件转换过程；
- plugin：plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。

### 构造函数使用 new 操作符中间会经历什么

1.  创建一个新对象
2.  将构造函数的作用域赋给新对象（因此 this 就指向这个新对象）
3.  执行构造函数中的代码（为这个新对象添加属性）
4.  返回新对象

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###
