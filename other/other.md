### 什么是设计模式？设计模式如何解决复杂问题？

设计模式描述了一个在我们周围不断发生的问题，以及解决该问题方案的核心。有了设计模式，我们就可以一次又一次的使用该方案而不用重复劳动。
设计模式主要通过两个方面来解决复杂问题：

- 分解：将复杂问题分解成多个简单问题。
- 抽象：忽略问题的本质细节，去处理泛化和理想化了的对象模型。

### 什么是白箱复用和黑箱复用？

- 白箱复用就是 B 类继承 A 类的功能，同时需要了解 A 类的内部细节，从而达到复用的效果，耦合性较强。
- 在黑箱复用中，B 类只需要关注 A 类所暴露的一些外部方法即可达到复用的效果，达到了解耦的效果。

### 介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景

- 观察者模式中主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知。
- 一对多时使用观察者模式，多对多时使用订阅-发布模式。

### 简述面向对象的设计原则

**依赖倒置原则**

- 高层模块（稳定）不应该依赖低层模块（变化），两者都应该依赖于抽象（稳定）；
- 抽象（稳定）不应该依赖于实现细节（变化），实现细节（变化）应该依赖于抽象（稳定）；

**开放封闭原则**

- 对扩展开放，对更改封闭；
- 类模块应该是可扩展的，但是不可修改；

**单一职责原则**

- 一个类应该只有一个引起它变化的原因；
- 变化的方向隐含了类的责任；

**Liskov 替换原则**

- 子类必须能够替换他们的基类（IS-A）；
- 继承表达类型抽象；

**接口隔离原则**

- 不应该强迫客户端使用他们不用的方法；
- 接口应该小而完备；

**优先使用对象组合，而不是类继承**

- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”；
- 继承在某种程度上破坏了封装性，子类父类耦合度高；
- 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低；

**封装变化点**

- 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合；

**针对接口编程，而不是针对实现编程**

- 不将变量类型声明为具体的某个类，而是声明为某个接口；
- 客户程序无需获取对象的具体类型，只需要知道对象所具有的接口；
- 减少系统中的各部分依赖关系，从而实现“高内聚、低耦合”的类型设计方案；

### 简述你了解的设计模式及应用场景

**组件协作**  
Template Method 模式：

- 模式定义：定义一个操作中的算法的骨架（稳定），将一些步骤（变化）延迟到子类中；
- 应用场景：React 生命周期；

Observer 模式：

- 模式定义：定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。
- 应用场景：Redux 实现。

Strategy 模式：

- 定义：定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展、子类化）。
- 应用：国际化、多种输入一种输出。

**单一职责**  
Decorator 模式：

- 模式定义：动态（组合）地给一个对象增加一些额外的职责，就增加功能而言，Decorator 模式比生成子类（继承）更加灵活（消除重复代码、减少子类个数）；
- 应用场景：React 高阶组件、中间件。

Bridge 模式：

- 模式定义：将抽象业务（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。
- 应用场景：组件组合功能。

**对象创建**  
Factory Method 模式：

- 模式定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使得一个类的实例化延迟（目的：解耦，手段：抽象）到子类。
- 应用场景：React.createElement(...)、gin.Default(...)

Abstract Factory:

- 模式定义：提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定他们具体的类。
- 应用场景：SQL API 类有多个成员类，比如连接类、创建类、操作类，将这些组合起来放在一个 Factory 类中，由这个类完成多个成员类的创建工作。

**对象性能**  
Singleton 模式：

- 模式定义：保证一个类只有一个实例，并提供一个该实例的全局访问点。
- 应用场景：游戏中的主角类实例。

FlyWeight（享元模式）：

- 模式定义：运行共享技术有效地支持大量细粒度的对象。
- 应用场景：对象池优化。

**接口隔离**  
Facade 模式：

- 模式定义：为子系统中的一组接口提供一致（稳定）的界面，Facade 模式定义了一个高层接口，这个接口使得这个子系统更加容易使用（复用）。
- 应用场景：各种硬件驱动。

Proxy 模式：

- 模式定义：为其他对象提供一种代理以控制（隔离、使用接口）对这种对象的访问。
- 应用场景：使用闭包导出方法（代理操作对象）。

Adapter 模式：

- 模式定义：将一个类的接口转换为客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- 应用场景：Go 中的 http.ListenAndServe 所接受的结构体只需要实现 ServeHTTP 方法即可满足 http 的接口条件。

Composite 模式：

- 模式定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性（稳定）。
- 应用场景：在树形结构中，Parent Node 和 Child Node 都继承于同一抽象类 Node，都使用 process 方法来执行自身的方法。

### webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的

- 当修改了一个或多个文件；
- 文件系统接收更改并通知 webpack；
- webpack 重新编译构建一个或多个模块，并通知 HMR（Hot Module Replacement） 服务器进行更新；
- HMR Server 使用 Websocket 通知 HMR runtime 需要更新，HMR runtime 通过 HTTP 请求更新 jsonp；
- HMR runtime 替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新；

### 前端性能优化

关键原则：

- 减少请求数量
- 减小资源体积
- 提高请求效率
- 合理使用缓存
- 优化渲染与交互性能

**减少 HTTP 请求数**

- 合并 CSS 和 JS 文件（构建时合并）
- 雪碧图（sprite）/ Icon Font / SVG sprite
- 使用懒加载、按需加载（import() 动态加载模块）

**减小资源体积**

- 图片压缩（如 TinyPNG、WebP 格式）
- JS/CSS 压缩（如 Terser、cssnano）
- 删除无用代码（Tree shaking、PurgeCSS）
- 使用 Brotli 或 Gzip 压缩传输内容

**合理使用缓存**

- HTTP 缓存（Cache-Control、ETag）
- 使用 Service Worker 做离线缓存（如 Workbox）
- CDN 加速：将静态资源分发到离用户更近的节点

**资源加载顺序优化**

- CSS 放 `<head>`，JS 放 `<body> `尾部或 defer
- 使用 async / defer 控制 JS 加载顺序

- preload / prefetch / preconnect：提前加载关键资源

**首屏加载优化**

- SSR（服务端渲染）或 CSR + Skeleton 屏
- 延迟加载不重要的内容（如滚动加载）
- 精简首屏资源，仅加载首屏必要资源

**减少重排（Reflow）与重绘（Repaint）**

- 避免频繁修改样式，可使用 class 批量变更
- 合理使用 transform 和 opacity（GPU 加速）

**虚拟 DOM 和长列表优化**

- 使用 React/Vue 等框架时注意 diff 策略
- 虚拟滚动（Virtual List）技术如 react-window、vue-virtual-scroller

**动画优化**

- 使用 requestAnimationFrame 控制动画帧率
- 避免使用性能差的 CSS 属性如 box-shadow、filter

**JavaScript 性能优化**

- 减少作用域链层级、避免内存泄漏
- 使用事件委托降低事件绑定成本
- 节流（throttle）、防抖（debounce）处理高频事件
- 使用 Web Worker 分离计算密集任务
- 异步加载：懒加载组件、异步请求数据

**移动端优化（H5）**

- 启用 viewport 配置响应式布局
- 优化触摸事件处理（如 passive event）
- 减少使用第三方 UI 库体积
- 使用 FastClick 或 CSS touch-action 提高响应速度

**性能监控与分析**

- 使用 Lighthouse（Chrome DevTools）评估性能指标
- Core Web Vitals（FCP、LCP、CLS、TTFB、INP）
- 使用监控工具（如 Sentry、LogRocket、阿里云前端监控）采集真实用户性能数据

### 前端性能分析

chrome Lighthouse 最新规则，前端性能指标考量主要有

- **FCP（First Contenful Paint）**
  - 首次内容绘制是指测量页面从开始加载到页面内容（文本、图片、背景图、svg 元素或非白色 canvas 元素）的任何部分在屏幕上完成渲染的时间
- **SI（Speed Index）**
  - 衡量页面加载期间内容以视觉方式显示的速度。通俗的讲，就是网页从有东西到完全显示内容的可见填充速度。
- **LCP（Largest Contentful Paint）**
  - 最大（最有意义）内容绘制，是指根据页面首次开始加载的时间点来报告可视区域内可见的最大图像或者文本块完成渲染的相对时间。
- **TBT（Total Blocking Time）**
  - 总阻塞时间，是页面被阻塞响应用户交互的总时间。
- **CLS（Cumulative Layout Shift）**
  - 累计布局偏移（CLS）是测量视觉稳定性的重要指标。是整个页面声明周期内发生的所有意外布局偏移中最大一连串的布局偏移分数。

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###
