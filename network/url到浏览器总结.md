## 从浏览器接收 url 到开启网络请求线程

### 多进程的浏览器

- Browser 进程：浏览器的主进程（负责协调、主控），只有一个
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- GPU 进程：最多一个，用于 3D 绘制
- 浏览器渲染进程（内核）：默认每个 Tab 页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白 tab 会合并成一个进程）

### 多线程的浏览器内核

每一个 tab 页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程

- GUI 渲染线程

  - 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
  - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
  - 注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

- JS 引擎线程

  - 也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）
  - JS 引擎线程负责解析 Javascript 脚本，运行代码。
  - JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
  - 同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

- 事件触发线程

  - 归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）
  - 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
  - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
  - 注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

- 定时触发器线程

  - 传说中的 setInterval 与 setTimeout 所在线程
  - 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
  - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
  - 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

- 异步 http 请求线程

  - 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
  - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

### Browser 进程和浏览器内核（Renderer 进程）的通信过程

- Browser 进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 RendererHost 接口传递给 Render 进程
- Renderer 进程的 Renderer 接口收到消息，简单解释后，交给渲染线程，然后开始渲染

- 渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染
  - 当然可能会有 JS 线程操作 DOM（这样可能会造成回流并重绘）
  - 最后 Render 进程将结果传递给 Browser 进程
- Browser 进程接收到结果并将结果绘制出来

## 开启网络线程到发出一个完整的 http 请求

### DNS 查询得到 IP

如果输入的是域名，需要进行 dns 解析成 IP，大致流程：

- 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host
- 如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP

注意，域名查询时有可能是经过了 CDN 调度器的（如果有 cdn 存储功能的话）

而且，需要知道 dns 解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑 dns-prefetch 优化

### tcp/ip 请求

http 的本质就是 tcp/ip 请求
需要了解 3 次握手规则建立连接以及断开连接时的四次挥手
tcp 将 http 长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输

**tcp/ip 的并发限制（http2 无此限制）**

浏览器对同一域名下并发的 tcp 连接是有限制的（2-10 个不等）  
而且在 http1.0 中往往一个资源下载就需要对应一个 tcp/ip 请求

**get 和 post 的区别**
get 和 post 虽然本质都是 tcp/ip，但两者除了在 http 层面外，在 tcp/ip 层面也有区别。  
get 会产生一个 tcp 数据包，post 两个具体就是：

- get 请求时，浏览器会把 headers 和 data 一起发送出去，服务器响应 200（返回数据），
- post 请求时，浏览器先发送 headers，服务器响应 100 continue，浏览器再发送 data，服务器响应 200（返回数据）。

### 五层因特网协议栈

五层因特网协议栈其实就是：

1. 应用层(dns,http) DNS 解析成 IP 并发送 http 请求
2. 传输层(tcp,udp) 建立 tcp 连接（三次握手）
3. 网络层(IP,ARP) IP 寻址
4. 数据链路层(PPP) 封装成帧
5. 物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

也有一个完整的 OSI 七层框架，与之相比，多了会话层、表示层。  
OSI 七层框架：**物理层、数据链路层、网络层、传输层、会话层、表示层、应用层**

- 表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等
- 会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程

## 从服务器接收到请求到对应后台接收到请求

### 负载均衡

**用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了 nginx 控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的 HTTP 响应，并将它反馈给用户**

## 后台的处理

一般后台都是部署到容器中的，所以一般为：

- 先是容器接受到请求（如 tomcat 容器）
- 然后对应容器中的后台程序接收到请求（如 java 程序）
- 然后就是后台会有自己的统一处理，处理完后响应响应结果

概括下：

- 一般有的后端是有统一的验证的，如安全拦截，跨域验证
- 如果这一步不符合规则，就直接返回了相应的 http 报文（如拒绝请求等）
- 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
- 等程序执行完毕后，就会返回一个 http 响应包（一般这一步也会经过多层封装）
- 然后就是将这个包从后端发送到前端，完成交互

## 后台和前台的 http 交互

前后端交互时，http 报文作为信息的载体

### http 报文结构

报文一般包括了：通用头部，请求/响应头部，请求/响应体

### cookie 以及优化

cookie 是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的 session 使用。

场景如下（简述）：

在登陆页面，用户登陆了  
此时，服务端会生成一个 session，session 中有对于用户的信息（如用户名、密码等）  
然后会有一个 sessionid（相当于是服务端的这个 session 对应的 key）  
然后服务端在登录页面中写入 cookie，值就是:jsessionid=xxx  
然后浏览器本地就有这个 cookie 了，以后访问同域名下的页面时，自动带上 cookie，自动检验，在有效时间内无需二次登陆。

另外，由于在同域名的资源请求时，浏览器会默认带上本地的 cookie，针对这种情况，在某些场景下是需要优化的(http2 不用)。

- 将静态资源分组，分别放到不同的域名下（如 static.base.com）
- 而 page.base.com（页面所在域名）下请求时，是不会带上 static.base.com 域名的 cookie 的，所以就避免了浪费

在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上 pc）  
此时就需要用到一种优化方案：dns-prefetch（让浏览器空闲时提前解析 dns 域名，不过也请合理使用，勿滥用）

### gzip 压缩

明确 gzip 是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持），
而且 gzip 压缩效率很好（高达 70%左右）

### 长连接与短连接

首先看 tcp/ip 层面的定义：

- 长连接：一个 tcp/ip 连接上可以连续发送多个数据包，在 tcp 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）
- 短连接：通信双方有数据交互时，就建立一个 tcp 连接，数据发送完成后，则断开此 tcp 连接

然后在 http 层面：

- http1.0 中，默认使用的是短连接，也就是说，浏览器没进行一次 http 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接
- http1.1 起，默认使用长连接，使用长连接会有这一行 Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 http 的 tcp 连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接

注意： **keep-alive 不会永远保持，它有一个持续时间，一般在服务器中配置（如 apache），另外长连接需要客户端和服务器都支持时才有效**

### http 2.0

简述下 http2.0 与 http1.1 的显著不同点：

- http1.1 中，每请求一个资源，都是需要开启一个 tcp/ip 连接的，所以对应的结果是，每一个资源对应一个 tcp/ip 请求，由于 tcp/ip 本身有并发数限制，所以当资源一多，速度就显著慢下来
- http2.0 中，一个 tcp/ip 请求可以请求多个资源，也就是说，只要一次 tcp/ip 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。

所以，如果 http2.0 全面应用，很多 http1.1 中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）

简述下 http2.0 的一些特性：

- 多路复用（即一个 tcp/ip 连接可以请求多个资源）
- 首部压缩（http 头部压缩，减少体积）
- 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）
- 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）
- 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）

### https

https 与 http 的区别就是： 在请求前，会建立 ssl 链接，确保接下来的通信都是加密的，无法被轻易截取分析

## 单独拎出来的缓存问题，http 的缓存

### 强缓存与弱缓存

缓存可以简单的划分成两种类型：强缓存（200 from cache）与协商缓存（304）

区别简述如下：

- 强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起 http 请求
- 协商缓存（304）时，浏览器会向服务端发起 http 请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存
  对于协商缓存，使用 Ctrl + F5 强制刷新可以使得缓存无效

但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）

### 缓存头部简述

属于强缓存控制的：

- （http1.1）Cache-Control/Max-Age
- （http1.0）Pragma/Expires

注意：Max-Age 不是一个头部，它是 Cache-Control 头部的值

属于协商缓存控制的：

- （http1.1）If-None-Match/E-tag
- （http1.0）If-Modified-Since/Last-Modified

**Max-Age 相比 Expires**

但是有时候会有这样一种情况-客户端时间和服务端不同步  
那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期  
所以一般 http1.1 后不推荐使用 Expires  
而 Max-Age 使用的是客户端本地时间的计算，因此不会有这个问题  
因此推荐使用 Max-Age。  
注意，如果同时启用了 Cache-Control 与 Expires，Cache-Control 优先级高。

**E-tag 相比 Last-Modified**

**Last-Modified：**

表明服务端的文件最后何时改变的  
它有一个缺陷就是只能精确到 1s，  
然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效

**而 E-tag：**  
是一种指纹机制，代表文件相关指纹  
只有文件变才会变，也只要文件变就会变，  
也没有精确时间的限制，只要文件一遍，立马 E-tag 就不一样了  
如果同时带有 E-tag 和 Last-Modified，服务端会优先检查 E-tag

## 解析页面流程

### 流程简述

1. 解析 HTML，构建 DOM 树
2. 解析 CSS，生成 CSS 规则树
3. 合并 DOM 树和 CSS 规则，生成 render 树
4. 布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算
5. 绘制 render 树（paint），绘制页面像素信息
6. 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上

### HTML 解析，构建 DOM

解析 HTML 到构建出 DOM 当然过程可以简述如下：  
**Bytes → characters → tokens → nodes → DOM**

列举其中的一些重点过程：

1. Conversion 转换：浏览器将获得的 HTML 内容（Bytes）基于他的编码转换为单个字符
2. Tokenizing 分词：浏览器按照 HTML 规范标准将这些字符转换为不同的标记 token。每个 token 都有自己独特的含义以及规则集
3. Lexing 词法分析：分词的结果是得到一堆的 token，此时把他们转换为对象，这些对象分别定义他们的属性和规则
4. DOM 构建：因为 HTML 标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样
   例如：body 对象的父节点就是 HTML 对象，然后段略 p 对象的父节点就是 body 对象

### 生成 CSS 规则

简述为：  
Bytes → characters → tokens → nodes → CSSOM

### 构建渲染树

当 DOM 树和 CSSOM 都有了后，就要开始构建渲染树了

### 渲染

有了 render 树，接下来就是开始渲染

步骤就是：

1. 计算 CSS 样式
2. 构建渲染树
3. 布局，主要定位坐标和大小，是否换行，各种 position overflow z-index 属性
4. 绘制，将图像绘制出来

Layout 和 Repaint 的概念是有区别的：

- Layout，也称为 Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
- Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了

回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，  
所以优化方案中一般都包括，尽量避免回流。

**什么会引起回流？**

1. 页面渲染初始化
2. DOM 结构改变，比如删除了某个节点
3. render 树变化，比如减少了 padding
4. 窗口 resize
5. 最复杂的一种：获取某些属性，引发回流，
   很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，
   但是除了 render 树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括

   - offset(Top/Left/Width/Height)
   - scroll(Top/Left/Width/Height)
   - cilent(Top/Left/Width/Height)
   - width,height
   - 调用了 getComputedStyle()或者 IE 的 currentStyle

回流一定伴随着重绘，重绘却可以单独出现

所以一般会有一些优化方案，如：

- 减少逐项更改样式，最好一次性更改 style，或者将样式定义为 class 并一次性更新
- 避免循环操作 dom，创建一个 documentFragment 或 div，在它上面应用所有 DOM 操作，最后再把它添加到 window.document
- 避免多次读取 offset 等属性。无法避免则将它们缓存到变量
- 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高

注意：改变字体大小会引发回流

### 简单层与复合层

普通图层

- 浏览器默认会将整个页面作为一个主图层进行渲染。
- 所有 DOM 元素会在这个图层中统一绘制。
- 改变普通图层内容，会影响整个主图层的重绘和重排。

复合图层（合成图层）

- 某些元素或操作会被浏览器自动提升为独立的图层，称为复合图层（Compositing Layer）。
- 它们会被单独绘制、并在最后一步由 GPU 与主图层合成。
- 利于硬件加速、减少主图层重绘，提高性能。

简单介绍下：

- 可以认为默认只有一个复合图层，所有的 DOM 节点都是在这个复合图层下的
- 如果开启了硬件加速功能，可以将某个节点变成复合图层
- 复合图层之间的绘制互不干扰，由 GPU 直接控制
- 而简单图层中，就算是 absolute 等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速

**如何变成复合图层（硬件加速）**

- 最常用的方式：translate3d、translateZ
- opacity 属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
- will-chang 属性（这个比较偏僻），一般配合 opacity 与 translate 使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）
- `<video><iframe><canvas><webgl>`等元素
- 其它，譬如以前的 flash 插件

**absolute 和硬件加速的区别**

可以看到，absolute 虽然可以脱离普通文档流，但是无法脱离默认复合层。  
所以，就算 absolute 中信息改变时不会改变普通文档流中 render 树，  
但是，浏览器最终绘制时，是整个复合层绘制的，所以 absolute 中信息的改变，仍然会影响整个复合层的绘制。  
而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）

**复合图层的作用？**

一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能，
但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡

**硬件加速时请使用 index**

使用硬件加速时，尽可能的使用 index，防止浏览器默认给后续的元素创建复合层渲染

### 资源外链的下载

在解析 html 时，会遇到一些资源连接，此时就需要进行单独处理了

**遇到外链时的处理**

当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1 中是每一个资源的下载都要开启一个 http 请求，对应一个 tcp/ip 链接）
http2?

**遇到 CSS 样式资源**

CSS 资源的处理有几个特点：

- CSS 下载时异步，不会阻塞浏览器构建 DOM 树
- 但是会阻塞渲染，也就是在构建 render 时，会等到 css 下载解析完毕后才进行（这点与浏览器优化有关，防止 css 规则不断改变，避免了重复的构建）
- 有例外，media query 声明的 CSS 是不会阻塞渲染的

**遇到 JS 脚本资源**

JS 脚本资源的处理有几个特点：

- 阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析 HTML
- 浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已
- defer 与 async，普通的脚本是会阻塞浏览器解析的，但是可以加上 defer 或 async 属性，这样脚本就变成异步了，可以等到解析完毕后再执行

注意，defer 和 async 是有区别的： defer 是延迟执行，而 async 是异步执行。

简单的说（不展开）：

- async 是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 onload 前，但不确定在 DOMContentLoaded 事件的前或后
- defer 是延迟执行，在浏览器看起来的效果像是将脚本放在了 body 后面一样（虽然按规范应该是在 DOMContentLoaded 事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）

**遇到 img 图片类资源**

遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有 src 的地方

**loaded 和 domcontentloaded**

简单的对比：

DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片(譬如如果有 async 加载的脚本就不一定完成)
load 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了

## CSS 的可视化格式模型

### 包含块（Containing Block）

- 根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块
- static 和 relative 的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建
- fixed 的包含块是当前可视窗口
- absolute 的包含块由它最近的 position 属性为 absolute、relative 或者 fixed 的祖先元素创建

  - 如果其祖先元素是行内元素，则包含块取决于其祖先元素的 direction 特性
  - 如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界

### 控制框（Controlling Box）

**块框:**

- 块级元素会生成一个块框（Block Box），块框会占据一整行，用来包含子 box 和生成的内容
- 块框同时也是一个块包含框（Containing Box），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围

如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）

**行内框：**

- 一个行内元素生成一个行内框
- 行内元素能排在一行，允许左右有其它元素

## BFC（Block Formatting Context）

块级格式上下文

总结几点 BFC 特点：

- 内部 box 在垂直方向，一个接一个的放置
- box 的垂直方向由 margin 决定，属于同一个 BFC 的两个 box 间的 margin 会重叠
- BFC 区域不会与 float box 重叠（可用于排版）
- BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此
- 计算 BFC 的高度时，浮动元素也参与计算（不会浮动坍塌）

如何触发 BFC？

- 根元素
- float 属性不为 none
- position 为 absolute 或 fixed
- display 为 inline-block, flex, inline-flex，table，table-cell，table-caption
- overflow 不为 visible

## JS 引擎解析过程

### JS 的解释阶段

JS 是解释型语音，所以它无需提前编译，而是由解释器实时运行

引擎对 JS 的处理过程可以简述如下：

1. 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）
2. 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）
3. 使用翻译器（translator），将代码转为字节码（bytecode）
4. 使用字节码解释器（bytecode interpreter），将字节码转为机器码

### JS 的预处理阶段

- 分号补全
- 变量提升

### JS 的执行阶段

- 浏览器首次载入脚本，它将创建全局执行上下文，并压入执行栈栈顶（不可被弹出）
- 然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部
- 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。
- 这样依次执行（最终都会回到全局执行上下文）

**一个执行上下文包含三个主要部分：**

- 变量环境（Variable Environment）：变量、函数声明等；**变量环境是对早期（es5） 变量对象（Variable Object, VO） 的一个“语义升级”或“抽象提升”，本质是同一个东西，但 ES6 起有所扩展和区分。**
- 词法环境（Lexical Environment）：作用域链；（用于处理 let、const、块级作用域；也用于创建作用域链。）
- this 绑定：当前 this 的值；

#### this 指针

this 引用的事函数据以执行的环境对象；
this 是执行上下文环境的一个属性，而不是某个变量对象的属性。

- this 是没有一个类似搜寻变量的过程
- 当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻
- this 的值只取决中进入上下文时的情况

### 回收机制

常用的两种垃圾回收规则是：

- 标记清除
- 引用计数

Javascript 引擎基础 GC 方案是（simple GC）：mark and sweep（标记清除），简单解释如下：

- 遍历所有可访问的对象。
- 回收已不可访问的对象。

#### GC 优化策略

分代回收（Generation GC）

目的是通过区分“临时”与“持久”对象:

- 多回收“临时对象”区（young generation）
- 少回收“持久对象”区（tenured generation）
- 减少每次需遍历的对象，从而减少每次 GC 的耗时。

## 从 Event Loop 谈 JS 的运行机制

- JS 分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。
- 一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

## 事件循环进阶：macrotask 与 microtask

- macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）

  - 每一个 task 会从头到尾将这个任务执行完毕，不会执行其它
  - 浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染

- microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务

  - 也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前
  - 所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染
  - 也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）

- macrotask：主代码块，setTimeout，setInterval 等（可以看到，事件队列中的每一个事件都是一个 macrotask）
- microtask：Promise，process.nextTick 等

总结下运行机制：

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染
- 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取）
